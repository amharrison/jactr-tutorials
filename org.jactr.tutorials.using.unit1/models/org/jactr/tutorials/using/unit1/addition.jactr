<?xml version="1.0" encoding="UTF-8"?>
<actr>
  <model name="Unit1 Addition" version="6">
  <!-- 
  Modules define the core theoretic structure of a cognitive model. At the very
  minimum, you require a declarative and a procedural module. The class is the actual
  implementing class of the module's logic. 
  
  For this basic model, we only need the declarative, procedural, retrieval and goal modules.
  We are using the ACT-R 6 versions. As the theory evolves, the implementations do as well, as
  independent implementations.
  
  These modules define the buffers that are available (goal, retrieval). Their contents can be
  modified at the end of this file.
  
  Selecting any class name and hitting Ctrl(Command)-Shift-T will allow you to view that
  source code.
   -->
    <modules>
      <module class="org.jactr.core.module.declarative.six.DefaultDeclarativeModule6"/>
      <module class="org.jactr.core.module.procedural.six.DefaultProceduralModule6"/>
      <module class="org.jactr.core.module.goal.six.DefaultGoalModule6"/>
      <module class="org.jactr.core.module.retrieval.six.DefaultRetrievalModule6"/>
    </modules> 
    
    <!-- 
    One can also contribute extensions at this point. These are similar to modules in that they contribute
    functionality, but do so in an atheoretic manner. Extensions are typically the glue that connects
    a model to an interface, experiment, etc.
    
    One can also <import src="" /> other model files into this one.
     -->
 
 <!-- 
  All declarative memory contents are specified within this block. Chunk-types and chunks. 
  Note: all types and chunks defined in this block are encoded. This is true except in one
  small case : if you define a chunk, and it is only referenced by a buffer as its contents on startup,
  that chunk will be created and added to the buffer (but not encoded)
  -->
    <declarative-memory>
    
    <!-- 
      here is a basic chunk-type, with no parentage (parent="parentName"). The slots
      are immediately defined and provided with a default value. This is our goal representation.
 
      lisp : (chunk-type add arg1 arg2 sum count)
      -->
      <chunk-type name="add">
        <slot name="arg1" equals="nil"/>
        <slot name="arg2" equals="nil"/>
        <slot name="count" equals="nil"/>
        <slot name="sum" equals="nil"/>
      </chunk-type>

<!-- 
 another simple chunk-type definition. This contains the encoding of counting sequence facts.
 
 lisp : (chunk-type count-order first second)
 -->
      <chunk-type name="count-order">
        <slot name="first" equals="nil"/>
        <slot name="second" equals="nil"/>
      </chunk-type>


      <!--
       here is the goal chunk that will be added to the goal buffer (see end of file)
       
       lisp :  (add-dm   (second-goal ISA add arg1 5 arg2 2))
      -->
      <chunk name="second-goal" type="add">
        <slot name="arg1" equals="5"/>
        <slot name="arg2" equals="2"/>
        <slot name="count" equals="nil"/>
        <slot name="sum" equals="nil"/>
      </chunk>
      
      
      <chunk name="third-goal" type="add">
        <slot name="arg1" equals="1"/>
        <slot name="arg2" equals="5"/>
        <slot name="count" equals="nil"/>
        <slot name="sum" equals="nil"/>
      </chunk>


      <!-- 
        chunks for count-order 
        When creating this code by hand, the editor will attempt to guess slot names, types, and chunk
        names for you. Go ahead, delete the slot name below, then hit Ctrl-Space.
        
        Similarly, if you select an element, the editor will highlight it's occurrences in the file
         (except for strings and numbers).
         
         If you ctrl-click on a type, chunk, or production - you will be taken to its definition. Try
         ctrl-clicking on "count-order" below.
         
         
         lisp: (add-dm
   (a ISA count-order first 0 second 1)
   (b ISA count-order first 1 second 2)
   (c ISA count-order first 2 second 3)
   (d ISA count-order first 3 second 4)
   (e ISA count-order first 4 second 5)
   (f ISA count-order first 5 second 6)
   (g ISA count-order first 6 second 7)
   (h ISA count-order first 7 second 8)
   (i ISA count-order first 8 second 9)
   (j ISA count-order first 9 second 10))
      -->
      <chunk name="a" type="count-order">
        <slot name="first" equals="0.0"/>
        <slot name="second" equals="1.0"/>
      </chunk>

      <chunk name="b" type="count-order">
        <slot name="first" equals="1.0"/>
        <slot name="second" equals="2.0"/>
      </chunk>

      <chunk name="c" type="count-order">
        <slot name="first" equals="2.0"/>
        <slot name="second" equals="3.0"/>
      </chunk>

      <chunk name="d" type="count-order">
        <slot name="first" equals="3.0"/>
        <slot name="second" equals="4.0"/>
      </chunk>

      <chunk name="e" type="count-order">
        <slot name="first" equals="4.0"/>
        <slot name="second" equals="5.0"/>
      </chunk>

      <chunk name="f" type="count-order">
        <slot name="first" equals="5.0"/>
        <slot name="second" equals="6.0"/>
      </chunk>

      <chunk name="g" type="count-order">
        <slot name="first" equals="6.0"/>
        <slot name="second" equals="7.0"/>
      </chunk>

      <chunk name="h" type="count-order">
        <slot name="first" equals="7.0"/>
        <slot name="second" equals="8.0"/>
      </chunk>

      <chunk name="i" type="count-order">
        <slot name="first" equals="8.0"/>
        <slot name="second" equals="9.0"/>
      </chunk>

      <chunk name="j" type="count-order">
        <slot name="first" equals="9.0"/>
        <slot name="second" equals="10.0"/>          
      </chunk>

    </declarative-memory>
    
    <!-- 
     All productions go within the procedural-memory tags. 
     -->
    <procedural-memory>
    
    <!--
     initialize-addition starts the model off by launching
     a retrieval. Note how we query the retrieval buffer to
     be sure it is free to access.
 
     lisp : (P initialize-addition
   =goal>
      ISA         add
      arg1        =num1
      arg2        =num2
      sum         nil
==>
   =goal>
      sum         =num1
      count       0
   +retrieval>
      isa        count-order
      first      =num1
)
      -->
      <production name="initialize-addition">
        <conditions>
          <match buffer="goal" type="add">
            <slot name="arg1" equals="=num1"/>
            <slot name="arg2" equals="=num2"/>
            <slot name="sum" equals="nil"/>
          </match>
        </conditions>
        <actions>
          <modify buffer="goal">
            <slot name="count" equals="0.0"/>
            <slot name="sum" equals="=num1"/>
          </modify>
          <add buffer="retrieval" type="count-order">
            <slot name="first" equals="=num1"/>
          </add>
        </actions>
      </production>


 <!--
       after all has processed, we will have the answer
       lisp :
(P terminate-addition
   =goal>
      ISA         add
      count       =num
      arg2        =num
      sum         =answer
==>
   =goal>
      count nil
)
      -->        
      <production name="terminate-addition">
        <conditions>
          <match buffer="goal" type="add">
            <slot name="arg1" equals="=num1"/>
            <slot name="arg2" equals="=num2"/>
            <slot name="count" equals="=num2"/>
            <slot name="sum" equals="=answer"/>
          </match>
        </conditions>
        <actions>
          <modify buffer="goal">
            <slot name="count" equals="nil"/>
          </modify>
          <output>"=num1 + =num2 is =answer"</output>
        </actions>
      </production>
        

  <!--
       increment-count and increment-sum work in concert
       with each other, scaffolding the next until terminate
       can be reached.
 
       Note: unlike the lisp example, we do check to make sure
       that the retrieval module is not busy. It's not strictly
       necessary, but always good to make sure you are free before
       making a request
 
       lisp :
(P increment-count
   =goal>
      ISA         add
      sum         =sum
      count       =count
   =retrieval>
      ISA         count-order
      first       =count
      second      =newcount
==>
   =goal>
      count       =newcount
   +retrieval>
      isa        count-order
      first      =sum
)
     -->
      <production name="increment-count">
        <conditions>
          <match buffer="goal" type="add">
            <slot name="sum" equals="=sum"/>
            <slot name="count" equals="=count"/>
          </match>
          <match buffer="retrieval" type="count-order">
            <slot name="first" equals="=count"/>
            <slot name="second" equals="=newCount"/>
            <slot name=":state" equals="free"/>
          </match>
        </conditions>
        <actions>
          <modify buffer="goal">
            <slot name="count" equals="=newCount"/>
          </modify>
          <add buffer="retrieval" type="count-order">
            <slot name="first" equals="=sum"/>
          </add>
          <output>"That was the =newCount finger"</output>
          <output>"Will try to retrieval a count-order first =sum "</output>
        </actions>
      </production>


  <!--
      increment the sum. This time, instead of checking the
      retrieval state in a separate query, we are using the blended
      match with a :slotName (:state). :slotNames are treated as if
      they were in a query.
 
      lisp:
(P increment-sum
   =goal>
      ISA         add
      sum         =sum
      count       =count
    - arg2        =count
   =retrieval>
      ISA         count-order
      first       =sum
      second      =newsum
==>
   =goal>
      sum         =newsum
   +retrieval>
      isa        count-order
      first      =count
)
      -->
      <production name="increment-sum">
        <conditions>
          <match buffer="goal" type="add">
            <slot name="sum" equals="=sum"/>
            <slot name="count" equals="=count"/>
            <slot name="arg2" not="=count"/>
          </match>

          <match buffer="retrieval" type="count-order">
            <slot name="first" equals="=sum"/>
            <slot name="second" equals="=newSum"/>
            <slot name=":state" equals="free"/>
          </match>
        </conditions>
        <actions>
          <modify buffer="goal">
            <slot name="sum" equals="=newSum"/>
          </modify>
          <add buffer="retrieval" type="count-order">
            <slot name="first" equals="=count"/>
          </add>
          <output>"=newSum"</output>
          <output>"Will try to retrieval a count-order first =count"</output>
        </actions>
      </production>

       



    </procedural-memory>


<!-- here we have the goal buffer definition, and we're telling it that third-goal is the focus -->
    <buffer name="goal" chunk="third-goal"/>

<!-- 
 two very common model parameters: unused cycle skipping allows the model to jump
 forward in time when there is nothing to be done. This can reduce model run times,
 but is generally not idle if you've got a model that is monitoring the outside
 environment for changes.
 Persistent execution allows a model to continue running even without a goal (the
 normal termination condition for act-r models)
 -->    
    <parameters>
      <parameter name="EnableUnusedCycleSkipping" value="true"/>
      <parameter name="EnablePersistentExecution" value="false"/>
    </parameters>


  </model>
</actr>
